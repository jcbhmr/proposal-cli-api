<pre class='metadata'>
Title: CLI API
Shortname: cli-api
Group: wintertc
Status: DRAFT
URL: https://cli-api.proposal.wintertc.org/
Repository: https://github.com/WinterTC55/proposal-minimum-common-api
Editor: TODO
Abstract: Standard CLI APIs
Markup Shorthands: markdown yes
Markup Shorthands: idl yes
</pre>

Introduction {#intro}
=====================

TODO

<xmp class=idl>
interface CLI {
  // defined in partial interfaces below
};
</xmp>

Arguments {#args}
-----------------

TODO

<xmp class=idl>
partial interface CLI {
  readonly attribute FrozenArray<DOMString> args;
};
</xmp>

<div class=example>

{{args}} omits any runtime-specific arguments from the returned arguments list. The name of the file passed to the JavaScript runtime is considered a runtime-specific argument and is therefore omitted. Note that there is not always a script file name available (REPL or eval mode).

```sh
node \
  --env-file=./.env.development \
  --import @wintertc55/cool-loader \
  --no-warnings \
  ./scripts/greet.js Alice Bob "de la Cruz"
```

```js
for (const arg of CLI.args) {
  console.log(`Hello, ${arg}!`);
}
// Output:
// Hello, Alice!
// Hello, Bob!
// Hello, de la Cruz!
```

</div>

Environment Variables {#env}
----------------------------

<xmp class=idl>
interface CLIEnv {
  getter DOMString? get(DOMString key);
  setter undefined set(DOMString key, DOMString value);
  deleter undefined delete(DOMString key);
  boolean has(DOMString key);
  readonly attribute unsigned long size;
  iterable<DOMString, DOMString>;
};

partial interface CLI {
  readonly attribute CLIEnv env;
};
</xmp>

Standard streams {#stdio}
-------------------------

<xmp class=idl>
interface CLIReadableStream : ReadableStream {
  Promise<ReadableStreamReadResult> read(); // Uint8Array
  boolean supports(DOMString feature);
};

partial interface CLI {
  readonly attribute CLIReadableStream stdin;
};
</xmp>

<xmp class=idl>
typedef (BufferSource or Blob or USVString) CLIWriteChunkType;

interface CLIWritableStream : WritableStream {
  Promise<undefined> write(FileSystemWriteChunkType data);
  boolean supports(DOMString feature);
};

partial interface CLI {
  readonly attribute CLIWritableStream stdout;
  readonly attribute CLIWritableStream stderr;
};
</xmp>

<div class=example>

This is an example of checking for terminal capabilities using `CLI.stdout.supports()` with some common well-known feature names.

```js
if (CLI.stdout.supports("color")) {
  console.log("%cSupports color!", "color: green;");
}
if (CLI.stdout.supports("truecolor")) {
  console.log("%cSupports truecolor!", "color: rgb(126, 16, 216);"); // custom purple
}
if (CLI.stdout.supports("emoji")) {
  console.log("Supports emoji! ðŸš€âœ¨");
}
if (CLI.stdout.supports("hyperlink")) {
  console.log(`Supports hyperlinks! ${ansiEscapes.link("WinterCG", "https://wintercg.org/")}`);
}
if (CLI.stdout.supports("image")) {
  const response = await fetch("https://example.org/cool-image.png");
  const data = await response.arrayBuffer();
  console.log(`Supports images! ${ansiEscapes.image(data)}`);
}
```

</div>

<!--

## Explainer

This explainer is a WIP draft, as such may drastically change in the future. This is primarily focused on what should be exposed and how. There may be a "V2" in future with more high-level APIs like parsing arguments, but for now this is only [ensuring such APIs could be implemented in userland](https://github.com/wintercg/proposal-cli-api/issues/6).

Process-level information such as arguments and environment variables are commonly used in many CLI applications. Currently, JS runtimes do not have any standardized method to get this information:
- Node: `process.argv`<sup>1</sup>, `process.env`<sup>3</sup>
- Deno: `Deno.args`<sup>2</sup>, `Deno.env`<sup>4</sup>
- Bun: `Bun.argv`<sup>1</sup>, `Bun.env`<sup>3</sup>

<sup>(0: Bare arguments including binary path and script path, excluding options consumed. 2: Arguments excluding runtime args. 3: Bare object. 4: Map-like object)</sup>

### Arguments

Arguments should not be exposed raw, instead they [should have "runtime args" removed](https://github.com/wintercg/proposal-cli-api/issues/3). "Runtime args" are any arguments which are specific to the runtime itself: runtime binary path, script path, and runtime arguments. For example, `Deno.args` currently excludes these while `process.argv` has the runtime binary path and script path. Runtimes may wish to expose the raw arguments themselves via their own API, but that is intentionally not standardized in this proposal.

#### Examples

| Raw arguments | Expected | `process.argv` (comparison) |
| ---- | -------- | -------------- |
| `runtime script.js` | `[]` | `[ '/bin/runtime', '/tmp/script.js' ]` |
| `runtime script.js example` | `[ 'example' ]` | `[ '/bin/runtime', '/tmp/script.js', 'example' ]` |
| `runtime script.js one two three` | `[ 'one', 'two', 'three' ]` | `[ '/bin/runtime', '/tmp/script.js', 'one', 'two', 'three' ]` |
| `runtime --cool-runtime-argument script.js foo bar` | `[ 'foo', 'bar' ]` | `[ '/bin/runtime', '/tmp/script.js', 'foo', 'bar' ]` |
| `runtime script.js --cool-runtime-argument foo bar` | `[ '--cool-runtime-argument', 'foo', 'bar' ]` | `[ '/bin/runtime', '/tmp/script.js', '--cool-runtime-argument', 'foo', 'bar' ]` |

### Environment Variables

Environment variables should be exposed as a exotic object with getter/setter/deleter/etc as specified below. This behaves similar to `process.env`, but strictly specified. It is also similar to `localStorage` in some aspects (getter/setter/deleter/etc for named access of an external resource).

> [!IMPORTANT]
> This section is a draft of a **simplified** ES-like spec to detail the concept and is [under discussion](https://github.com/wintercg/proposal-cli-api/issues/3). This should probably be moved to a separate spec file.

#### EnvironmentVariables [[Get]] ( *P* )

The EnvironmentVariables getter gets the given environment variable in a [host-defined](https://tc39.es/ecma262/#host-defined) manner. It performs the following steps when called:

1. If *P* [is not a String](https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type), return **undefined**.
1. If, checking in a [host-defined](https://tc39.es/ecma262/#host-defined) manner, the environment variable *P* is set, then
    1. Return the value of the environment variable *P* in a [host-defined](https://tc39.es/ecma262/#host-defined) manner.
1. Return **undefined**.

> [!NOTE]
> Some platforms, notably Windows, have case insensitive environment variable lookups. This should be handled in the host-defined manners. For example, if `FOO` was set and `foo` was looked up, the value of `FOO` would be used. If `foo` was then set, the original case `FOO` would retain (like a case-insensitive pointer lookup).

#### EnvironmentVariables [[GetOwnProperty]] ( *P* )

The EnvironmentVariables [[GetOwnProperty]] internal method returns a [normal completion containing](https://tc39.es/ecma262/#sec-completion-record-specification-type) a [Property Descriptor](https://tc39.es/ecma262/#sec-property-descriptor-specification-type) or **undefined**. It gets the given environment variable in a [host-defined](https://tc39.es/ecma262/#host-defined) manner. It performs the following steps when called:

1. If *P* [is not a String](https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type), return **undefined**.
1. If, checking in a [host-defined](https://tc39.es/ecma262/#host-defined) manner, the environment variable *P* is set, then
    1. Let *value* be the value of the environment variable *P* retrieved in a [host-defined](https://tc39.es/ecma262/#host-defined) manner.
    1. Return the PropertyDescriptor { [[Value]]: *value*, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
1. Return **undefined**.

#### EnvironmentVariables [[Set]] ( *P*, *V* )

The EnvironmentVariables setter sets the given environment variable in a [host-defined](https://tc39.es/ecma262/#host-defined) manner. It performs the following steps when called:

1. If *P* [is not a String](https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type), return **false**.
1. Let *value* be ? [ToString](https://tc39.es/ecma262/#sec-tostring)(*V*).
1. Set the environment variable *P* to *value* in a [host-defined](https://tc39.es/ecma262/#host-defined) manner.
1. Return **true**.

#### EnvironmentVariables [[Delete]] ( *P* )

The EnvironmentVariables deleter unsets the given environment variable in a [host-defined](https://tc39.es/ecma262/#host-defined) manner. It performs the following steps when called:

1. If *P* [is not a String](https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type), return **false**.
1. If, checking in a [host-defined](https://tc39.es/ecma262/#host-defined) manner, the environment variable *P* is set, then
    1. Unset the environment variable *P* in a [host-defined](https://tc39.es/ecma262/#host-defined) manner.
1. Return **true**.

> [!NOTE]
> Set and unset environment variables both return **true** for deletion.

#### EnvironmentVariables [[HasProperty]] ( *P* )

The EnvironmentVariables [[HasProperty]] internal method checks if the given environment variable is set in a [host-defined](https://tc39.es/ecma262/#host-defined) manner. It performs the following steps when called:

1. If *P* [is not a String](https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type), return **false**.
1. If, checking in a [host-defined](https://tc39.es/ecma262/#host-defined) manner, the environment variable *P* is set, then
    1. Return **true**.
1. Return **false**.

#### EnvironmentVariables [[OwnPropertyKeys]] ( )

The EnvironmentVariables [[OwnPropertyKeys]] internal method returns a list of set environment variables retrieved in a [host-defined](https://tc39.es/ecma262/#host-defined) manner. It performs the following steps when called:

1. Return a list of set environment variables retrieved in a [host-defined](https://tc39.es/ecma262/#host-defined) manner.

> [!NOTE]
> For EnvironmentVariables we intentionally use [[OwnPropertyKeys]] instead of newer Iterator, entries, etc as there could be environment variables with those names (even if unlikely). Ideally `Object.keys(CLI.env)`, `for (const name in CLI.env)`, `{ ...CLI.env }` should all work from these definitions.

> [!NOTE]
> For now, [[DefineOwnProperty]], and more are left knowingly unspecified.

> [!NOTE]
> Should we also have `get`/`set`/`has`/`delete` methods separately as well as getter/setter/etc?


### Terminal Metadata

The following metadata (capabilities/preferences) about the terminal should be exposed:
- Whether the terminal is interactive or non-interactive
- Whether color should be used or [avoided](https://no-color.org/)

[// todo: exposed how?](https://github.com/wintercg/proposal-cli-api/issues/9)

### Exiting

There should be an `exit` function, optionally allowing an exit code number defaulting to `0` (`exit(code?: number)`).

// todo: exit hooks/listeners

### Stdout

// todo

### Stdin

// todo

## Why standardize?

Currently, if you want the same script which uses arguments or other CLI APIs to work across runtimes, you have to add specific code for each runtime:

```js
let args = [];

if (typeof process !== 'undefined') args = process.argv.slice(2);
if (typeof Deno !== 'undefined') args = Deno.args.slice();
// ...
```

While this could be helped with a library (boilerplate :/) or by more runtimes implementing `process` (not a standard :/), WinterCG looks like a good place to really standardize these APIs. The core goal of this is to make this CLI API become the default, the one used by most people and runtimes; even some runtimes which not interested in the entirety of WinterCG as they likely will want/need an API which does some of this scope anyway. This API should be good enough that people want to use it regardless of the bonus that it is specified and (in the future) standardized. (TL;DR: It is important we make this API great, not just specified.)

For the origin and selfish (@CanadaHonk) reasons, I was looking at adding an arguments API to my JS engine+runtime and didn't know how I should expose them, so started this proposal :^)

-->